## 리스트
- 동적 배열로 구현되어 있다.  

| 언어 | 동적배열  | 
|---|---|
|Python|list()|
|C++|std::vector|
|Java|ArrayList|

- 파이썬의 리스트는 스택과 큐에서 사용 가능한 모든 연산을 함께 재공하여 편리하다.

- 리스트의 주요 연산 시간 복잡도  

| 연산 | 시간 복잡도  | 설명  |  
|---|---|---| 
| len(a) | O(1)  | 전체 요소의 개수를 리턴한다.  |
| a[i]  | O(1)  | 인덱스 i의 요소를 가지고 온다.  |
| a[i:j] | O(k)  | i부터 j까지 슬라이스의 길이만큼인 k개의 요소를 가져온다. 이 경우, 객체 k개에 대한 조회가 필요하다.  |
| element in a  | O(n)  | elem 요소가 존재하는지 확인한다. 처음부터 **순차** 탐색 하므로 n만큼 시간이 소요된다.  |
| a.count(elem)  | O(n)  | elem 요소의 개수를 리턴한다.  | 
| a.index(elem)  | O(n)  | elem 요소의 인덱스를 리턴한다.  |  
| a.append(elem)  | O(1)  | 리스트 마지막에 elem 요소를 추가한다.  | 
| a.pop()  | O(1)  |  리스트 마지막 요소를 추출한다. *스택* 연산이다. | 
| a.pop(0)  | O(n)  | 리스트 첫번째 요소를 추출한다. *큐*의 연산이다. 이 경우 전체 복사가 필요하므로 n만큼 소요된다. 나중에 다시 살펴보겠지만, 큐의 연산을 주로 사용한다면 리스트보다는 O(1)에 가능한 *데크(Deque)* 사용을 권장한다.  | 
| del a[i]  | O(n)  | i에 따라 다르다. 최악의 경우 O(n)이다.  | 
| a.sort()  | O(nlogn)  | Timsort(팀소트)를 사용하며, 최선의 경우 O(n)에도 실행될 수 있다.  |  
| min(a), max(a)  | O(n)  | 최솟값/최댓값을 계산하기 위해서는 전체를 선형 탐색해야 한다.  | 
| a.reverse()  | O(n)  | 뒤집는다. 리스트는 입력 순서가 유지되므로 뒤집게 되면 입력 순서가 반대가 된다.  |  

- 없는 인덱스 참조 시 오류가 나므로 try 구문 이용하자.

- 그 외
```
a=list() # 선언법, a=[]도 가능
a.insert(3,5) # 3번째 자리에 5를 삽입한다.
a[1:4:2] # Step 지정: 홀수 번째 인덱스의 값만 가져올 수 있다.(인덱스 1,3 값)
del a[1] # 인덱스로 해당 요소 삭제
a.remove(3) # 값으로 해당 요소 삭제
```
### 리스트의 특징
- 연속된 공간에 요소를 배치하는 배열의 장점과 다양한 type을 연결해 배치하는 연결 리스트의 장점을 모두 취한 형태를 띤다.
= 파이썬의 모든 자료형은 원시 타입이 아닌 객체로 되어 있다. 리스트는 이처럼 객체로 되어 있는 모든 자료형을 포인터로 연결한다.
따라서 정수,문자,불리언 등 제각기 다양한 type을 동시에 단일 리스트에서 관리하는 것이 가능하다. 이러한 특징은 매우 강력하며 매우 편리하게
활용할 수 있다. 그러나, 각 자료형의 크기는 저마다 서로 다르기 때문에 이들을 연속된 메모리 공간에 할당하는 것은 불가능하다.
- 즉, 각각의 객체에 대한 참조로 구현할 수 밖에 없어 속도 면에서는 불리하다.

## 딕셔너리
- Hash Table로 구현되어 있다.

| 언어 | 해시 테이블  | 
|---|---|
|Python|dict()|
|C++|std::unordered_map|
|Java|HashMap|

- 인덱스를 숫자로만 지정할 수 있는 리스트와 달리, 딕셔너리는 문자, 집합까지 불변 객체를 모두 키로 사용할 수 있다.
- 딕셔너리의 주요 연산 시간 복잡도

| 연산 | 시간 복잡도  | 설명  |  
|---|---|---| 
| len(a) | O(1)  | 전체 요소의 개수를 리턴한다.  |
| a[key]  | O(1)  | key를 조회하여 값을 리턴한다.  |
| a[key]=value | O(1)  | key/value 값을 삽입한다.  |
| key in a  | O(1)  | 딕셔너리에 key 가 존재하는지 확인한다. |

- 대부분의 연산이 O(1)에 처리 가능한 매우 우수한 자료형이다.
- 파이썬 3.7+부터는 내부적으로 인덱스를 이용해 입력 순서를 유지한다.
- 파이썬 3.6 이하부터는, 입력 순서가 유지되지 않아 collections.OrderedDict() 자료형을 별도로 제공한다.
- 존재하지 않는 key 참조 시, 오류가 나므로 try 구문 혹은 if문 을 이용하는 것이 좋다.

- 그 외
```
collections.defaultdict() # 조회 시 항상 디폴트 값을 생성해, 키 오류를 방지한다.
collections.Counter() # 요소의 값을 키로 하고, 개수를 값 형태로 만들어 counting 한다.
a=dict() #a={} 선언법
try:
  print(a['key4'])
except KeyError:
  print('존재하지 않는 키')
 
if 'key4' in a:
  print('존재하는 키')
else:
  print('존재하지 않는 키')

for k,v in a.items(): # items() 메소드를 사용하면 for 반복문으로 key와 value를 각각 꺼내올 수 있다.
  print(k,v)
```

### 딕셔너리 Module
1. defaultdict 객체
```
a=collections.defaultdict(int)
a['A']=5
a['B']=4
a['C']+=1
a # defaultdict(<class 'int'>, {'A':5, 'B':4, 'C':1})
```
- C는 존재하지 않는 키이지만, defaultdict 객체는 Error 없이 바로 +1 연산이 가능하다.
- default 값인 0을 기준으로 자동으로 생성한 후, 여기에 1을 더해 최종적으로 1이 만들어진다.

2. Counter 객체
```
a=[1,2,3,4,5,5,5,6,6,]
b=collections.Counter(a)
b # Counter({5: 3, 6: 2, 1: 1, 2: 1, 3: 1, 4: 1})
```
- 각 아이템에 대한 개수를 계산해서 딕셔너리로 리턴한다.
- 개수를 자동으로 계산해주기 때문에 매우 편리하며, 여러 분야에서 다양하게 활용된다.
- 가장 빈도 수가 높은 요소는 most_common()을 사용하면 된다.
```
b.most_common(2) # 빈도가 높은 2개 요소 추출, [(5,3),(6,2)]
```

## 부록 (타입 선언)
```
type([]) # <class 'list'>
type(()) # <class 'tuple'>
type({}) # <class 'dict'>
type({1}) #<class 'set'> 키 없이 캆만 1로 선언할 경우, 결과는 집합 자료형이다.
```
